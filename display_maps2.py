# Install Folium beforehands: pip install folium, pip install pandas
import os
import config as config
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import geopandas as gpd
import folium
from folium import FeatureGroup, LayerControl, Map, Marker, plugins
import webbrowser
from shapely.geometry import Polygon
import numpy as np
import os, sys
import ogr
from math import ceil
import pyproj
from pyproj import Transformer
import shapely.geometry


#Define the name of the files containing the aggregated indexes per geographical location,
#following the processing by the DINA Data Ingestion module

def generate_grid (bounding_box):
    

    # Set up projections
    
    transformer = Transformer.from_crs( 'epsg:4326', 'epsg:3857')    # 'epsg:3857' = metric; same as EPSG:900913
    transformer_back = Transformer.from_crs('epsg:3857', 'epsg:4326')    # go back to 'epsg:4326'
    # Create corners of rectangle to be transformed to a grid
    sw = shapely.geometry.Point(bounding_box[0])
    ne = shapely.geometry.Point(bounding_box[1])

    
    # Project corners to target projection
    transformed_sw = transformer.transform(sw.x, sw.y) # Transform NW point to 3857
    transformed_ne = transformer.transform(ne.x, ne.y) # .. same for SE

    municipi_df = gpd.read_file(config.municipi_geo)

    i = 0
    # Iterate over 2D area
    gridpoints = []
    properties_block_ID = []
    properties_municipi = []
    x = transformed_sw[0]
    while x < transformed_ne[0]:
        y = transformed_sw[1]
        while y < transformed_ne[1]:
            grid_sw=transformer_back.transform(x, y)
            grid_se=transformer_back.transform(x+config.block_width, y)
            grid_ne=transformer_back.transform(x+config.block_width , y+config.block_height)
            grid_nw=transformer_back.transform(x, y+config.block_height)
            p = shapely.geometry.Polygon([   
                [grid_sw[1],grid_sw[0]], 
                [grid_se[1],grid_se[0]], 
                [grid_ne[1],grid_ne[0]], 
                [grid_nw[1],grid_nw[0]]]) 
            gridpoints.append(p)
            municipi = '?'
            for index, row in municipi_df.iterrows():
                if p.centroid.within(row['geometry']):
                    municipi = row['nome']
            properties_municipi.append(municipi)                
            properties_block_ID.append (i)
            i += 1
            y += config.block_height 
        x += config.block_width 

    grid = gpd.GeoDataFrame({'geometry':gridpoints, 'block_ID':properties_block_ID,'municipi':properties_municipi },crs='EPSG:4326')
    grid.to_file("grid.geojson", driver='GeoJSON')
    return grid


def createHeatMapWithTimeFromIndexFile(indexFile):
    print("Generating HeatMap from " + indexFile)

    #Read data files generated by the DINA Open Data Ingestion module for the city of Roma, Italy
    index_df = pd.read_csv(indexFile, dtype=object)
    #print(index_df.head(5)) #print 5 first rows to check in the logs

    # Ensure we are handling Lat/Long as floats
    index_df['Latitude'] = index_df['Latitude'].astype(float)
    index_df['Longitude'] = index_df['Longitude'].astype(float)

    # Filter the data file for rows, then columns to display 2020 data only
    #heatmap_index_df = index_df[index_df['Year']=='2020'] 
    #heatmap_index_df = index_df[['Latitude', 'Longitude']]

    heatmap_index_df = index_df

    #Prepare the Data Frame to generate the heatmap
    heatmap_index_df['Index'] = heatmap_index_df['Index'].astype(float)
    heatmap_index_df = heatmap_index_df.dropna(axis=0, subset=['Latitude','Longitude', 'Index'])
    heatmap_index_df['Month']=heatmap_index_df['Month'].sort_values(ascending=True)
    
    heat_data = []
    for _, d in heatmap_index_df.groupby('Month'):
        heat_data.append([[row['Latitude'], row['Longitude'], row['Index']] for _, row in d.iterrows()])
    
    # Plot data on the map
    #heatMapIndex = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep'] #we are using 2020 data so datasets stops in Sep 2020
    heatmap_from_index = plugins.HeatMapWithTime(heat_data, auto_play=False, min_opacity = 0.05, radius = 175, max_opacity=0.3, use_local_extrema = True, gradient={0.0: 'lime', 0.7: 'orange', 1.0: 'red'})
  

    return heatmap_from_index

#Example of market that we could add for security inded (but the best is to have a heatmap)
#Marker(location=[41.902782,  12.496366],
#       popup='Security Index 2/10').add_to(feature_group_security_needs)

def createMap(filename, mapname):
    #Define coordinates of where we want to center our map (here, Roma in Italy)
    city_coords = [41.902782,  12.496366] 
    city_map = folium.Map(location = city_coords, zoom_start = 14, min_zoom=13, max_zoom=15)
    folium.TileLayer('cartodbpositron').add_to(city_map)
    createHeatMapWithTimeFromIndexFile(filename).add_to(city_map)
    folium.LayerControl().add_to(city_map)

    #Save the map and display it using a web browser
    mapFileName = os.path.join('map', 'DINA_' + mapname.replace(" ","_") + '.html')
    city_map.save(mapFileName)
    print ("Saving the generated map in: " + mapFileName)
    webbrowser.open(mapFileName, new=2)




# Module execution: launch main method
if __name__ == '__main__':
    print("Folium Version: " + folium.__version__)
        
    #Create maps
    #createMap(security_needs_index_file ,'Security Needs Index')  
    #createMap(connectivity_needs_index_file ,'Connectivity Needs Index')  
    #createMap(lighting_needs_index_file ,'Lighting Needs Index')  


    #Get the lower-left and upper-right bounds from the Municipi shapes to center the map
    municipi_shapes_bounds = folium.GeoJson (config.municipi_geo).get_bounds()
    #create_grid (municipi_shapes_bounds)
    generate_grid (municipi_shapes_bounds)
    city_coords = [
            municipi_shapes_bounds[0][0]+(municipi_shapes_bounds[1][0]-municipi_shapes_bounds[0][0])/2,
            municipi_shapes_bounds[0][1]+(municipi_shapes_bounds[1][1]-municipi_shapes_bounds[0][1])/2
            ] 
    print('Boundaries of the map are {}'.format(municipi_shapes_bounds))
    print('Centre of the map of {} is {}'.format(config.city_name, city_coords))
    
    choropleth = folium.Choropleth(
        geo_data=config.municipi_geo,
        name='Roma Municipi',
        columns=['nome'],
        key_on='feature.properties.nome',
        fill_color='YlGn',
        fill_opacity=0,
        line_opacity=1,
        legend_name='{} Municipi'.format(config.city_name)
        )
    
    map_grid = folium.Choropleth(
        geo_data='grid.geojson',
        name='City grid',
        columns=['municipi'],
        fill_color='RdPu',
        fill_opacity=0,
        line_opacity=0.1,
        line_color = 'blue',
        show=False
        )
    
    map_grid.geojson.add_child(
    folium.features.GeoJsonTooltip(['municipi'])
)

    city_map = folium.Map(location = city_coords, zoom_start = 10, min_zoom=9, max_zoom=15, control_scale=True)
    city_map.fit_bounds(municipi_shapes_bounds)
    folium.TileLayer('cartodbpositron').add_to(city_map)
        
    choropleth.add_to(city_map)
    map_grid.add_to(city_map)

    folium.LayerControl().add_to(city_map)

    test_name ='test map'
    #Save the map and display it using a web browser
    mapFileName = os.path.join('map', 'DINA_' + test_name.replace(" ","_") + '.html')
    city_map.save(mapFileName)
    print ("Saving the generated map in: " + mapFileName)
    webbrowser.open(mapFileName, new=2)

